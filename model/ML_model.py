from load_KG import LoadKGfrom collections import defaultdict class ObtainPathsByDynamicProgramming:    def __init__(self, one_hop, data,                  entity_dict, inverse_entity_dict,                  relation_dict, inverse_relation_dict):                self.one_hop = one_hop                self.data = data                self.entity_dict = entity_dict                self.inverse_entity_dict = inverse_entity_dict                self.relation_dict = relation_dict                self.inverse_relation_dict = inverse_relation_dict        '''    We apply recursion to find all the paths from s to any t    that is directly connected to s.        One may refer to LeetCode Problem 797 for details:        https://leetcode.com/problems/all-paths-from-source-to-target/    '''    def obtain_paths(self, s, length_bd):        if type(length_bd) != type(1) or length_bd < 1:                        raise TypeError("!!! invalid path length boundary, must >= 1 !!!")                #key is target entity that have direct connection to s        #value is all the paths from s to t        res = defaultdict(set)                #obtain all the direct neighbour of s        direct_nb = set()                for r in self.one_hop[s]:                        for t in self.one_hop[s][r]:                                direct_nb.add(t)                #in order to avoid circle, we make path contain the r        #path = [r1,r2,r3]        #we make Set contain the nodes        #set = {e1, e2}        #then, any new neighbour node in the set will not be considered        def helper(node, path, Set, res, direct_nb, length_bd, one_hop):                        if len(path) > 0 and node in direct_nb:                                res[node].add(tuple(path))                            if len(path) < length_bd:                                for r in one_hop[node]:                                        for t in one_hop[node][r]:                                                if t not in Set:                                                    helper(t, path + [r], Set.union({t}),                             res, direct_nb, length_bd, one_hop)                        helper(s, [], {s},         res, direct_nb, length_bd, self.one_hop)                return(res)                    if __name__ == "__main__":        print("!!! Kill the process if you see this when running the whole model !!!")        Class = LoadKG('../train.txt')    one_hop, data, entity_dict, inverse_entity_dict, relation_dict, inverse_relation_dict = Class.load_train_data()    Class_2 = ObtainPathsByDynamicProgramming(one_hop, data, entity_dict, inverse_entity_dict,                                               relation_dict, inverse_relation_dict)        result = Class_2.obtain_paths(0,2)        for ele in result[6551]:                if len(ele) <= 2:                        print(ele)    result = Class_2.obtain_paths(0,3)        for ele in result[6551]:                if len(ele) <= 2:                        print(ele)                '''# mode == True for training, False for Testing# define multi-layer bidirectional dynamic lstmdef stacked_bidirectional_BasicLSTM(inputs):    # TODO: add time_major parameter, and using batch_size = tf.shape(inputs)[0], and more assert    _inputs = inputs    if len(_inputs.get_shape().as_list()) != 3:    	raise ValueError("Inputs must be dim 3")    output_first_layer = None    for layer in range(num_layers):        with tf.variable_scope(None, default_name="bidirectional-rnn"):            rnn_cell_fw = rnn.LSTMCell(num_hidden, use_peepholes=True, initializer= tf.initializers.random_uniform(-init_scale, init_scale), forget_bias=1.0)#fw            rnn_cell_bw = rnn.LSTMCell(num_hidden, use_peepholes=True, initializer= tf.initializers.random_uniform(-init_scale, init_scale), forget_bias=1.0)#fw                        rnn_cell_fw = tf.nn.rnn_cell.DropoutWrapper(rnn_cell_fw, output_keep_prob=keep_prob)            rnn_cell_bw = tf.nn.rnn_cell.DropoutWrapper(rnn_cell_bw, output_keep_prob=keep_prob)            output, state = tf.nn.bidirectional_dynamic_rnn(rnn_cell_fw, rnn_cell_bw, _inputs, dtype=tf.float32)            if layer == 0:                            output_first_layer = tf.concat(output, 2)                 _inputs = output_first_layer            else:                _inputs = tf.concat(output, 2)    return output_first_layer, _inputs''''''for i in range(1, length_bd+1):        res[i] = set()#build the input and output set for dynamic programmingin_set = self.one_hop[s]ot_set = dict()#start the DP processfor i in range(1, length_bd+1):        #to speed up, we record all the end entities of all rels,    #then build the dict with entities to be key and rels be value    t_p_rel_dict = dict() #t_p for t prime: t'        for rel in in_set:                for t_p in in_set[rel]: #t_p for t prime: t'                    if t_p not in t_p_rel_dict:                                t_p_rel_dict[t_p] = {rel}                            else:                                t_p_rel_dict[t_p].add(rel)            #add to result    if t in t_p_rel_dict:                for rel_ele in t_p_rel_dict[t]:                        res[i].add(rel_ele)            #build output for next round    for t_p in t_p_rel_dict:                temp = self.one_hop[t_p]                holder = list()                for rel_ele in t_p_rel_dict[t_p]:                        if type(rel_ele) == type(1):                                temp_l = list()                temp_l.append(rel_ele)                                holder.append(temp_l)                        elif type(rel_ele) == type((1,2,3)):                                holder.append(list(rel_ele))                            else:                                raise TypeError("!!! path type is not correct !!!")                        for rel_2 in temp:                        for rel_ele in holder:                                rel_ele.append(rel_2)                                new_path = tuple(rel_ele)                if new_path not in ot_set:                                    ot_set[new_path] = set()                                for t_dp in temp[rel_2]: #t_dp is for t double prime: t''                                        ot_set[new_path].add(t_dp)    #complete the DP process    in_set = ot_set    ot_set = dict()'''