from load_KG import LoadKGfrom collections import defaultdictimport random class ObtainPathsByDynamicProgramming:    def __init__(self, one_hop, data,                  entity_dict, inverse_entity_dict,                  relation_dict, inverse_relation_dict):                self.one_hop = one_hop                self.data = data                self.entity_dict = entity_dict                self.inverse_entity_dict = inverse_entity_dict                self.relation_dict = relation_dict                self.inverse_relation_dict = inverse_relation_dict                self.decay = 0.6                self.threshold = 200        '''    Given an entity s, here is the function to find:      1. anyelse entity t that is directely connected to s      2. most of the paths (non-direct) from s to each t        One may refer to LeetCode Problem 797 for details:        https://leetcode.com/problems/all-paths-from-source-to-target/    '''    def obtain_paths(self, s, length_bd):        if type(length_bd) != type(1) or length_bd < 1:                        raise TypeError("!!! invalid path length boundary, must >= 1 !!!")                #here is the result dict. Its key is each entity t that is directly connected to s        #The value of each t is a set containing the paths from s to t        #These paths can be either the direct connection r, or a multi-hop path        res = defaultdict(set)                #direct_nb contains all the direct neighbour of s        direct_nb = set()                for r in self.one_hop[s]:                        for t in self.one_hop[s][r]:                                direct_nb.add(t)                '''        We use recursion to find the paths        On current node with the path [r1, ..., rk] and on-path entities {e1, ..., ek-1, node}        from s to this node, we further find the direct neighbor t' of this node.         If t' is not a on-path entity (not among e1,...ek-1), we recursively proceed to t'         '''        def helper(node, path, on_path_en, res, direct_nb, length_bd, one_hop, rate_in, length_dict):                        if len(path) > 0 and node in direct_nb:                                res[node].add(tuple(path))                                length_dict[len(path)] += 1                        '''            Also, we want to add restrict when the path-length get large,            otherwise the computation complexity exposes                        That is, we randomly decide whether we will do further recursion            when the path is long. The longer the path is, the lower the chance it will be for further recursion                        The last variable 'rate' is just this probability, we start to decay this rate when len_path >= 3                        Moreover, we will add another ultimate restrict: when the number of langth l path reaches the threshold, no more preceed            '''            if len(path) <= 1:                                rate_out = rate_in                            else:                                rate_out = self.decay * rate_in                        if len(path) < length_bd and length_dict[len(path) + 1] < self.threshold:                                #we randomly shuffle the relation r so that the reading in order is not fixed                temp_list = list()                                for r in one_hop[node]:                                        temp_list.append(r)                                    random.shuffle(temp_list)                                for r in temp_list:                                        for t in one_hop[node][r]:                                                if t not in on_path_en:                                                        rand = random.uniform(0, 1)                                                        if rand <= rate_out:                                                        helper(t, path + [r], on_path_en.union({t}),                                 res, direct_nb, length_bd, one_hop, rate_out, length_dict)                length_dict = defaultdict(int)                helper(s, [], {s},         res, direct_nb, length_bd, self.one_hop, 1, length_dict)                return(res, length_dict)                    if __name__ == "__main__":        print("!!! Kill the process if you see this when running the whole model !!!")        Class = LoadKG('../train.txt')    one_hop, data, entity_dict, inverse_entity_dict, relation_dict, inverse_relation_dict = Class.load_train_data()    Class_2 = ObtainPathsByDynamicProgramming(one_hop, data, entity_dict, inverse_entity_dict,                                               relation_dict, inverse_relation_dict)        result, length_dict = Class_2.obtain_paths(0, 20)            